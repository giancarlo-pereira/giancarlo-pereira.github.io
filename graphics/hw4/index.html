<script src=../matrix.js></script>
<script src=lib4.js></script>

<body bgcolor=white text=black link=black alink=black vlink=black>
<center>
<canvas id='canvas1' width=600 height=600></canvas>
</center>
</body>

<!!-------- CREATE A PROPERLY DESCRIPTIVE TITLE BELOW -------->

<script id='my_title' type='text/html'>
GIANCARLO PEREIRA HW4 -- REFLECTION AND REFRACTION
</script>

<!!-------- HERE IS WHERE YOU CAN PROVIDE A LONGER TEXT DESCRIPTION -------->

<script id='my_instructions' type='text/html'><font color=#000000>
Still figuring it out.
</script>

<script>

// VERTEX AND FRAGMENT SHADERS
let vertexShader = `
    attribute vec3 aPos;
    varying   vec3 vPos;
    void main() {
        gl_Position = vec4(aPos, 1.0);
        vPos = aPos;
    }
`;
let fragmentShader = `
    precision highp float;
    uniform float uTime, uFL;
    uniform vec3 uV, uCursor;
    uniform vec4 uSphere;
    varying vec3  vPos;

    vec3 bgColor = vec3(0.,0.,.05);

    void main() {    
        vec3 V = vec3(0.);
        vec3 W = normalize(vec3(vPos.xy, -uFL));
        vec3 L = normalize(vec3(1.));

        // SET BACKGROUND COLOR
    
        vec3 color = bgColor;
        if (uCursor.z > 0.) {
            color += vec3(.5,.5,.5);
        }
      vec3 C = uSphere.xyz;
      float r = uSphere.w;
      V -= C;
      float VV = dot(V,V);
      float VW = dot(V,W);

      float d = VW * VW - (VV - r*r);
      if (d > 0.) {
        float t = -VW - sqrt(d);
        if (t > 0.) {
        vec3 P = (V+C) + t * W;
	    vec3 N = normalize(P - C);
        color = vec3(.2, .2, .8) + max(0., dot(N, L));
        }
      }

        gl_FragColor = vec4(sqrt(color), 1.0);
    }
`;

document.body.innerHTML = [''
,'<center>'
,'<b><font size=6 color=#000000>' + my_title.innerHTML + '</b>'
,'<p><font size=5>' + my_instructions.innerHTML + '</p>'
,'<p>' + document.body.innerHTML + '</p>'
,'</center>'
].join('');

// CAMERA VIEW
let V = [0, 0, 0];
let focalLength = 2;

// CURSOR TRACKING
let rect = canvas1.getBoundingClientRect(), cursor = [0,0,0];
let setCursor = (e, z) => cursor = [  2 * (e.clientX - rect.left) / canvas1.width  - 1,
                                     -2 * (e.clientY - rect.top + window.scrollY) / canvas1.height + 1,
                                     z !== undefined ? z : cursor[2] ];

canvas1.onmousedown = e => setCursor(e, 1);
canvas1.onmousemove = e => setCursor(e,  );
canvas1.onmouseup   = e => setCursor(e, 0);

let m = new Matrix();

// canvas1.keyDown     = c => {
//     switch(c) {
//         case 'KeyA':        console.log(`you have pressed A`);          break; // 'A'
//         case 'KeyS':        console.log(`you have pressed S`);          break; // 'S'
//         case 'KeyD':        console.log(`you have pressed D`);          break; // 'D'
//         case 'KeyW':        console.log(`you have pressed W`);          break; // 'W'
//         case 'Space':       console.log(`you have pressed Space`);      break; // 'Space'
//         case 'Enter':       console.log(`you have pressed Enter`);      break; // 'Enter'
//         case 'Backspace':   console.log(`you have pressed Backspace`);  break; // 'Enter'
//         case 'ArrowUp':     console.log(`you have pressed ArrowUp`);    break; // 'ArrowUp'
//         case 'ArrowDown':   console.log(`you have pressed ArrowDown`);  break; // 'ArrowUp'
//         case 'ArrowRight':  console.log(`you have pressed ArrowRight`); break; // 'ArrowUp'
//         case 'ArrowLeft':   console.log(`you have pressed ArrowLeft`);  break; // 'ArrowUp'
//     }
// }

canvas1.keyDown     = c => {
    switch(c) {
        case 'KeyA':        console.log(m.rotateX(0.785));          break; // 'A'
        case 'KeyS':        console.log(m.rotateY(0.785));          break; // 'S'
        case 'KeyD':        console.log(m.rotateZ(0.785));          break; // 'D'
        case 'KeyW':        console.log(m.translate(0.25, 0.25, -2));      break; // 'W'
        case 'Space':       console.log(m.get());              break; // 'Space'
        case 'Enter':       console.log(m.identity());                   break; // 'Enter'
        case 'Backspace':   console.log(m.set([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]));  break; // 'Enter'
        case 'ArrowUp':     console.log(m.transform([4, 5, 3, 1]));    break; // 'ArrowUp'
        case 'ArrowDown':   console.log(`you have pressed ArrowDown`);  break; // 'ArrowUp'
        case 'ArrowRight':  console.log(`you have pressed ArrowRight`); break; // 'ArrowUp'
        case 'ArrowLeft':   console.log(`you have pressed ArrowLeft`);  break; // 'ArrowUp'
    }
}

function logMousePos(cursor) {
    console.log(`Cursor is at (${cursor[0]}, ${cursor[1]}) and its press status is ${cursor[2]}`);
}

setInterval(function() {
    logMousePos(cursor);
}, 100);


// SET THE CURRENT TIME IN SECONDS BEFORE RENDERING EACH FRAME.
let startTime = Date.now();



function animate(gl) {
    let x=0, y=0, z=-5, r=2;
    let data = [];
    let vector = m.transform([x, y, z, 1]);
    data.push(vector[0], vector[1], vector[2], r);
   let time = (Date.now() - startTime) / 1000;
   setUniform('3fv', 'uV', V);
   setUniform('1f', 'uTime', time);
   setUniform('1f', 'uFL', focalLength);
   setUniform('3fv', 'uCursor', cursor);
   setUniform('4fv', 'uSphere', data);
}

// START EVERYTHING.
gl_start(canvas1, vertexShader, fragmentShader);

</script>
   